package main

import (
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/minio/cli"
	{{quote .MainPackage }}
)


// vars ...
var (
 green = color.New(color.FgGreen)
 binHash = {{quote .Main.Hash}}
 binName = {{quote .Main.BinaryName }}
 Version = green.Sprintf("1.0.0")
 helpMessage = strings.TrimSpace(`{{.HelpFormat }}`)
 customHelpTemplate = `{{.CustomHelpTemplate}}`
)

func main(){
	app := cli.NewApp()
	app.Name = "{{lower .Main.BinaryName}}"
	app.Usage = "{{lower .Main.BinaryName}} [command]"
	app.Version = Version
	app.CustomAppHelpTemplate = helpMessage
	app.Description = "{{lower .Main.BinaryName}} generated by shogun"
	app.Action = mainAction

	app.Flags = []cli.Flag{
			cli.StringFlag{
				Name:  "t,timeout",
				Usage: "-t=4m to set timeout for function using context",
			},
	}

	app.Commands = []cli.Command{
		{
			Name:   "help",
			Action: helpAction,
			Flags:  []cli.Flag{
				cli.BoolFlag{
					Name:  "s,source",
					Usage: "-source to show source of command as well",
				},
			},
		},
	}

	app.RunAndExitOnError()
}

func helpAction(c *cli.Context) error {
	if c.NArg() == 0 {
		 fmt.Println(helpMessage)
		 return nil
	}

	return pkg.MainShogunHelp(
		c.Bool("source"),
		c.Args().First(),
		c.Args().Tail(),
		os.Stdin,
		wopCloser{Writer: os.Stdout},
	)
}

func mainAction(c *cli.Context) error {
	input := io.Reader(os.Stdin)

	// if data is coming through stdin then rock with that else
	// loaded rest of arguments has data.
	tail := c.Args().Tail()
	if !stdinHasData() && len(tail) != 0 {
		input = bytes.NewBufferString(strings.Join(tail, " "))
	}

	tm := makeDuration(c.String("timeout"), 0)
	if err := pkg.MainShogunExecute(
		c.Args().First(),
		c.Args().Tail(),
		input,
		wopCloser{Writer: os.Stdout},
		tm,
	); err != nil {
		if err == pkg.ErrNoDefault {
		 fmt.Println(helpMessage)
		 return nil
		}

		defer os.Exit(1)

		// Write error to stderr and only return err if attempt to write json failed.
		if jserr := json.NewEncoder(os.Stderr).Encode(struct{
			Err error `json:"error"`
			Method string `json:"method"`
			Message string `json:"message"`
			Timeout time.Duration `json:"duration"`
		}{
			Err: err,
			Timeout: tm,
			Method: c.Args().First(),
			Message: fmt.Sprintf("Command %+q failed with error", c.Args().First()),
		}); jserr != nil {
			return jserr
		}

		return nil
	}

	return nil
}

type wopCloser struct{
	io.Writer
}

// Close does nothing.
func (wopCloser) Close() error {
	return nil
}

// stdinHasData returns true/false if data is allocated into stdin.
func stdinHasData() bool {
	stat, err := os.Stdin.Stat()
	if err != nil {
		return false
	}

	if stat.Size() == 0 {
		return false
	}

	return true
}

var elapso = regexp.MustCompile(`(\d+)(\w+)`)
func makeDuration(target string, def int) time.Duration {
	if !elapso.MatchString(target) {
		return time.Duration(def)
	}

	matchs := elapso.FindAllStringSubmatch(target, -1)
	if len(matchs) <= 0 {
		return time.Duration(def)
	}

	match := matchs[0]

	if len(match) < 3 {
		return time.Duration(def)
	}

	dur := time.Duration(convertToInt(match[1], def))
	mtype := match[2]

	switch mtype {
	case "s":
		return dur * time.Second
	case "mcs":
		return dur * time.Microsecond
	case "ns":
		return dur * time.Nanosecond
	case "ms":
		return dur * time.Millisecond
	case "m":
		return dur * time.Minute
	case "h":
		return dur * time.Hour
	default:
		return time.Duration(dur) * time.Second
	}
}

func convertToInt(target string, def int) int {
	fo, err := strconv.Atoi(target)
	if err != nil {
		return def
	}
	return fo
}
