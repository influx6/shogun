// WARNING: Do not edit, this file is autogenerated.

package pkg

import (
  "io"
  "time"
  "encoding/json"
  "github.com/influx6/shogun/internal"
{{ if .Main.HasGoogleImports }}
  gctx "context"
{{end}}
{{ if .Main.HasFauxImports }}
  "github.com/influx6/faux/context"
{{end}}
{{ range $_, $elem := .Main.Functions }}{{range $path, $nick := .Imports }}
  {{$nick}} {{quote $path}}
{{end}}{{end}}
{{ range $_, $sub := .Subs}}
  {{$sub.CleanBinaryName}} {{quote $sub.PkgPath}}
{{end}}
)

var (
  subCommands = map[string]bool{ {{ range $_, $sub := .Subs}}
    {{ quote $sub.BinaryName}}: true,
{{end}} }
)

// MainShogunExecute executes necessary commands as needed from its arguments and
// writes corresponding outputs to provided `ougoing` writeCloser.
func MainShogunExecute(cmd string, args []string, incoming io.Reader, outgoing io.WriteCloser, ctxTimeout time.Duration) error {
  {{ if notequal (len .Subs) 0}}// If its a subcommand then let subcommand handle this.
  if subCommands[cmd] {
    var first string
    var rest []string

    if len(args) != 0 {
      first = args[0]
      rest = args[1:]
    }

    switch cmd {
    {{ range $_, $sub := .Subs}}
      case {{quote $sub.BinaryName}}:
        return {{$sub.CleanBinaryName}}.MainShogunExecute(first, rest, incoming, outgoing, ctxTimeout)
    {{end}}
    }
  }
  {{end}}switch cmd {
    {{ range $_, $elem := .Main.Functions }}{{range $elem.List}}
      case {{quote .Name}}, {{quote .RealName}}:
        {{if hasNoArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}()
              {{else}}
                {{.RealName}}()
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasContextArgument .Type }}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasMapArgument .Type }}
            var data map[string]interface{}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasReadArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(incoming)
              {{else}}
                {{.RealName}}(incoming)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming)
              {{else}}
                {{.RealName}}(ctx, incoming)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming)
              {{else}}
                {{.RealName}}(ctx, incoming)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasWriteArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(outgoing)
              {{else}}
                {{.RealName}}(outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, outgoing)
              {{else}}
                {{.RealName}}(ctx, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, outgoing)
              {{else}}
                {{.RealName}}(ctx, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStructArgument .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasImportedArgument .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasReadArgumentWithWriter .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(incoming, outgoing)
              {{else}}
                {{.RealName}}(incoming, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming, outgoing)
              {{else}}
                {{.RealName}}(ctx, incoming, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming, outgoing)
              {{else}}
                {{.RealName}}(ctx, incoming, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStructArgumentWithWriter .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasMapArgumentWithWriter .Type }}
            var data map[string]interface{}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasImportedArgumentWithWriter .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx gctx.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = gctx.Background()
              }else{
                ctx, canceller = gctx.WithTimeout(gctx.Background(), ctxTimeout)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}
              var ctx context.CancelableContext

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext()
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
    {{end}}
      default:
          {{ $defFunc := $elem.Default}} {{if notequal $defFunc nil}}
          {{end}}
    {{ end }}
  }
  return nil
}

// MainShogunHelp display help message for executable commands and subcommands.
func MainShogunHelp(source bool,  cmd string, args []string, incoming io.Reader, outgoing io.WriteCloser) error {
  {{ if notequal (len .Subs) 0}}// If its a subcommand then let subcommand handle this.
  if subCommands[cmd] {
    var first string
    var rest []string

    if len(args) != 0 {
      first = args[0]
      rest = args[1:]
    }

    switch cmd {
    {{ range $_, $sub := .Subs}}
      case {{quote $sub.BinaryName}}:
        return {{$sub.CleanBinaryName}}.MainShogunHelp(source, first, rest, incoming, outgoing)
    {{end}}
    }
  }
  {{end}}switch cmd {
    {{ range $_, $elem := .Main.Functions }}{{range $elem.List}}
      case {{quote .Name}}, {{quote .RealName}}:
        defer outgoing.Close()
        if source {
          if _, err := outgoing.Write([]byte(`{{.HelpMessageWithSource}}`)); err != nil {
            return err
          }

          return nil
        }

          if _, err := outgoing.Write([]byte(`{{.HelpMessage}}`)); err != nil {
            return err
          }

    {{end}}{{ end }}
  }
  return nil
}
