// WARNING: Do not edit, this file is autogenerated.

package {{.Main.PkgName}}

import (
  "io"
  "time"
  "encoding/json"
  "github.com/influx6/shogun/internals"
{{ if .Main.HasGoogleImports }}
  "context"
{{end}}
{{ if .Main.HasFauxImports }}
  "context"
{{end}}
{{ range $_, $elem := .Main.Functions }}{{range $path, $nick := .Imports }}
  {{$nick}} {{quote $path}}
{{end}}{{end}}
{{ range $_, $sub := .Subs}}
  {{$sub.CleanBinaryName}} {{quote $sub.PkgPath}}
{{end}}
)

// vars ...
var (
  ErrNoDefault = errors.New("No default command")
  subCommands = map[string]bool{ {{ range $_, $sub := .Subs}}
    {{ quote $sub.BinaryName}}: true,
{{end}} }
)

// MainShogunMeta returns ShogunFunc for all available functions to provide terse information with
// attached function for displaying or for testing.
func MainShogunMeta(cmd string, args []string) (internals.ShogunFunc, error) {
  {{ if notequal (len .Subs) 0}}// If its a subcommand then let subcommand handle this.
  if subCommands[cmd] {
    var first string
    var rest []string

    if len(args) != 0 {
      first = args[0]
      rest = args[1:]
    }

    switch cmd {
    {{ range $_, $sub := .Subs}}
      case {{quote $sub.BinaryName}}:
        return {{$sub.CleanBinaryName}}.MainShogunMeta(first, rest)
    {{end}}
    }
  }
  {{end}}switch cmd {
    {{ range $_, $elem := .Main.Functions }}{{range $elem.List}}
      case {{quote .Name}}, {{quote .RealName}}:
        return internals.ShogunFunc{
          Context: {{.Context}},
          Type: {{.Type}},
          Return: {{.Return}},
          NS: {{quote .Name}},
          Function: {{.RealName}},
          Name: {{quote .RealName}},
          Source: `{{.Source}}`,
          Flags: internals.Flags{
            {{range .Flags}}
              {
                EnvVar: {{quote .EnvVar}},
                Name: {{quote .Name}},
                Desc: {{quote .Desc}},
                Type: internals.FlagType({{.Type.Int}}),
              },
            {{end}}
          },
        }, nil
    {{end}}
    {{end}}
  }

  return internals.ShogunFunc{}, errors.New("Not found")
}

// MainShogunExecute executes necessary commands as needed from its arguments and
// writes corresponding outputs to provided `ougoing` writeCloser.
func MainShogunExecute(cmd string, args []string, flags []string, incoming io.Reader, outgoing io.WriteCloser, ctxTimeout time.Duration) error {
  {{ if notequal (len .Subs) 0}}// If its a subcommand then let subcommand handle this.
  if subCommands[cmd] {
    var first string
    var rest []string

    if len(args) != 0 {
      first = args[0]
      rest = args[1:]
    }

    switch cmd {
    {{ range $_, $sub := .Subs}}
      case {{quote $sub.BinaryName}}:
        return {{$sub.CleanBinaryName}}.MainShogunExecute(first, rest, flags, incoming, outgoing, ctxTimeout)
    {{end}}
    }
  }
  {{end}}

  switch cmd {
    {{ range $_, $elem := .Main.Functions }}{{range $elem.List}}
      case {{quote .Name}}, {{quote .RealName}}:

      {{if not (usesNoContext .Context) }}
        cmdFlags := internals.Flags{
          {{range .Flags}}
            {
              EnvVar: {{quote .EnvVar}},
              Name: {{quote .Name}},
              Desc: {{quote .Desc}},
              Type: internals.FlagType({{.Type.Int}}),
            },
          {{end}}
        }

        // If flags failed to load then cryout.
        flagVals, err := cmdFlags.Load(flags)
        if err != nil {
          return err
        }
      {{end}}

        {{if hasNoArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}()
              {{else}}
                {{.RealName}}()
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasContextArgument .Type }}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringArgument .Type }}
            var data bytes.Buffer

            if _, err := io.Copy(&data, incoming); err != nil && err != io.EOF {
              return err
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(data.String())
              {{else}}
                {{.RealName}}(data.String())
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String())
              {{else}}
                {{.RealName}}(ctx, data.String())
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String())
              {{else}}
                {{.RealName}}(ctx, data.String())
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringSliceArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(args)
              {{else}}
                {{.RealName}}(args)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args)
              {{else}}
                {{.RealName}}(ctx, args)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args)
              {{else}}
                {{.RealName}}(ctx, args)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasMapArgument .Type }}
            var data map[string]interface{}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasReadArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(incoming)
              {{else}}
                {{.RealName}}(incoming)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming)
              {{else}}
                {{.RealName}}(ctx, incoming)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming)
              {{else}}
                {{.RealName}}(ctx, incoming)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasWriteArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(outgoing)
              {{else}}
                {{.RealName}}(outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }
              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }


              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, outgoing)
              {{else}}
                {{.RealName}}(ctx, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, outgoing)
              {{else}}
                {{.RealName}}(ctx, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStructArgument .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }
              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }


              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasImportedArgument .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringArgumentWithWriter .Type }}
            var data bytes.Buffer

            if _, err := io.Copy(&data, incoming); err != nil && err != io.EOF {
              return err
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(data.String(), outgoing)
              {{else}}
                {{.RealName}}(data.String(), outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String(), outgoing)
              {{else}}
                {{.RealName}}(ctx, data.String(), outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String(), outgoing)
              {{else}}
                {{.RealName}}(ctx, data.String(), outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringSliceArgumentWithWriter .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(args, outgoing)
              {{else}}
                {{.RealName}}(args, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }
              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }


              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args, outgoing)
              {{else}}
                {{.RealName}}(ctx, args, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args, outgoing)
              {{else}}
                {{.RealName}}(ctx, args, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasReadArgumentWithWriter .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(incoming, outgoing)
              {{else}}
                {{.RealName}}(incoming, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming, outgoing)
              {{else}}
                {{.RealName}}(ctx, incoming, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming, outgoing)
              {{else}}
                {{.RealName}}(ctx, incoming, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStructArgumentWithWriter .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasMapArgumentWithWriter .Type }}
            var data map[string]interface{}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasImportedArgumentWithWriter .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
    {{end}}
    {{end}}
    default:
      {{if equal (len .Main.Default) 0}}
        return ErrNoDefault
      {{else}}
      {{range .Main.Default}}
      {{if not (usesNoContext .Context) }}
        cmdFlags := internals.Flags{
          {{range .Flags}}
            {
              EnvVar: {{quote .EnvVar}},
              Name: {{quote .Name}},
              Desc: {{quote .Desc}},
              Type: internals.FlagType({{.Type.Int}}),
            },
          {{end}}
        }

        // If flags failed to load then cryout.
        flagVals, err := cmdFlags.Load(flags)
        if err != nil {
          return err
        }
      {{end}}

        {{if hasNoArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}()
              {{else}}
                {{.RealName}}()
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasContextArgument .Type }}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx)
              {{else}}
                {{.RealName}}(ctx)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringArgument .Type }}
            var data bytes.Buffer

            if _, err := io.Copy(&data, incoming); err != nil && err != io.EOF {
              return err
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(data.String())
              {{else}}
                {{.RealName}}(data.String())
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String())
              {{else}}
                {{.RealName}}(ctx, data.String())
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String())
              {{else}}
                {{.RealName}}(ctx, data.String())
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringSliceArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(args)
              {{else}}
                {{.RealName}}(args)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args)
              {{else}}
                {{.RealName}}(ctx, args)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args)
              {{else}}
                {{.RealName}}(ctx, args)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasMapArgument .Type }}
            var data map[string]interface{}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasReadArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(incoming)
              {{else}}
                {{.RealName}}(incoming)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming)
              {{else}}
                {{.RealName}}(ctx, incoming)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming)
              {{else}}
                {{.RealName}}(ctx, incoming)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasWriteArgument .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(outgoing)
              {{else}}
                {{.RealName}}(outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }
              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }


              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, outgoing)
              {{else}}
                {{.RealName}}(ctx, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, outgoing)
              {{else}}
                {{.RealName}}(ctx, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStructArgument .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }
              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }


              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasImportedArgument .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}})
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringArgumentWithWriter .Type }}
            var data bytes.Buffer

            if _, err := io.Copy(&data, incoming); err != nil && err != io.EOF {
              return err
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(data.String(), outgoing)
              {{else}}
                {{.RealName}}(data.String(), outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String(), outgoing)
              {{else}}
                {{.RealName}}(ctx, data.String(), outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, data.String(), outgoing)
              {{else}}
                {{.RealName}}(ctx, data.String(), outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStringSliceArgumentWithWriter .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(args, outgoing)
              {{else}}
                {{.RealName}}(args, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }
              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }


              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args, outgoing)
              {{else}}
                {{.RealName}}(ctx, args, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, args, outgoing)
              {{else}}
                {{.RealName}}(ctx, args, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasReadArgumentWithWriter .Type }}
            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}(incoming, outgoing)
              {{else}}
                {{.RealName}}(incoming, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming, outgoing)
              {{else}}
                {{.RealName}}(ctx, incoming, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, incoming, outgoing)
              {{else}}
                {{.RealName}}(ctx, incoming, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasStructArgumentWithWriter .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasMapArgumentWithWriter .Type }}
            var data map[string]interface{}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
        {{if hasImportedArgumentWithWriter .Type }}
            {{if hasPrefix .Imports.Type "*"}}
            var data {{ trimPrefix .Imports.Type "*"}}
            {{else}}
            var data {{.Imports.Type}}
            {{end}}

            if err := json.NewDecoder(incoming).Decode(&data); err != nil {
              return fmt.Errorf("Expected Valid JSON: %+q", err)
            }

            {{if usesNoContext .Context }}
              {{if returnsError .Return }}
                return {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}({{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesGoogleContext .Context}}
              var ctx context.Context
              var canceller func()

              if ctxTimeout == 0 {
                ctx = context.Background()
              }else{
                ctx, canceller = context.WithTimeout(context.Background(), ctxTimeout)
              }

              for key, val := range flagVals {
                ctx = context.WithValue(ctx, key, val)
              }

              if canceller != nil {
                defer canceller()
              }

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
            {{if usesFauxContext .Context}}bag := context.ValueBagFrom(flagVals)
              var ctx context.Context

              if ctxTimeout == 0 {
                ctx = context.NewCnclContext(bag)
              }else{
                ctx = context.NewExpiringCnclContext(nil, ctxTimeout, bag)
              }

              defer ctx.Cancel()

              {{if returnsError .Return }}
                return {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
              {{else}}
                {{.RealName}}(ctx, {{if hasPrefix .Imports.Type "*"}}&data{{else}}data{{end}}, outgoing)
                return nil
              {{end}}
            {{end}}
        {{end}}
      {{end}}
      {{end}}
  }
}

// MainShogunHelp display help message for executable commands and subcommands.
func MainShogunHelp(source bool,  cmd string, args []string, incoming io.Reader, outgoing io.WriteCloser) error {
  defer outgoing.Close()

  {{ if notequal (len .Subs) 0}}// If its a subcommand then let subcommand handle this.
  if subCommands[cmd] {
    var first string
    var rest []string

    if len(args) != 0 {
      first = args[0]
      rest = args[1:]
    }

    switch cmd {
    {{ range $_, $sub := .Subs}}
      case {{quote $sub.BinaryName}}:
        return {{$sub.CleanBinaryName}}.MainShogunHelp(source, first, rest, incoming, outgoing)
    {{end}}
    }
  }
  {{end}}switch cmd {
    {{ range $_, $elem := .Main.Functions }}{{range $elem.List}}
      case {{quote .Name}}, {{quote .RealName}}:
        if source {
          if _, err := outgoing.Write([]byte(`{{.HelpMessageWithSource}}`)); err != nil {
            return err
          }
          return nil
        }

        if _, err := outgoing.Write([]byte(`{{.HelpMessage}}`)); err != nil {
          return err
        }
    {{end}}{{ end }}
    default:
        if _, err := outgoing.Write([]byte(`{{.Help}}`)); err != nil {
          return err
        }
  }
  return nil
}
